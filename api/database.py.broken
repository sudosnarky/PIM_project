"""
Database connection and management for the PARA InfoSystem API.

This module provides database connection handling, schema initialization,
and query utilities with proper c    def health_check(self) -> bool:
        """
        Check database health and connectivity.
        
        Returns:
            bool: True if database is accessible, False otherwise
        """
        try:
            with self.get_db_session() as db:
                db.execute("SELECT 1")
                return True
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False
    
    def execute_query(self, query: str, params: tuple = None):
        """
        Execute a SQL query and return results.
        
        Args:
            query: SQL query string
            params: Query parameters tuple
            
        Returns:
            Query results (fetchall for SELECT, cursor for others)
            
        Raises:
            DatabaseError: If query execution fails
        """
        try:
            with self.get_db_session() as db:
                if params:
                    cursor = db.execute(query, params)
                else:
                    cursor = db.execute(query)
                
                # For SELECT queries, return all rows
                if query.strip().upper().startswith('SELECT'):
                    return cursor.fetchall()
                else:
                    # For INSERT/UPDATE/DELETE, return cursor for lastrowid/rowcount
                    db.commit()
                    return cursor
                    
        except Exception as e:
            raise DatabaseError(f"Query execution failed: {e}")gement and error handling.
"""
import sqlite3
import logging
from typing import Optional, Generator
from contextlib import contextmanager

from config import settings

logger = logging.getLogger(__name__)


class DatabaseError(Exception):
    """Custom exception for database-related errors."""
    pass


class DatabaseManager:
    """
    Database manager for SQLite operations with connection pooling and error handling.
    
    This class provides methods for database initialization, connection management,
    and common database operations with proper error handling and logging.
    """
    
    def __init__(self, db_url: str = settings.database_url):
        """
        Initialize database manager.
        
        Args:
            db_url: Path to SQLite database file
        """
        self.db_url = db_url
        self.timeout = settings.database_timeout
        
    def get_connection(self) -> sqlite3.Connection:
        """
        Create and return a new database connection.
        
        Returns:
            sqlite3.Connection: Database connection with Row factory
            
        Raises:
            DatabaseError: If connection fails
        """
        try:
            conn = sqlite3.connect(
                self.db_url,
                timeout=self.timeout,
                check_same_thread=False
            )
            conn.row_factory = sqlite3.Row
            
            # Enable WAL mode for better concurrency
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute(f"PRAGMA busy_timeout={int(self.timeout * 1000)}")
            
            return conn
        except sqlite3.Error as e:
            logger.error(f"Database connection failed: {e}")
            raise DatabaseError(f"Failed to connect to database: {e}")
    
    @contextmanager
    def get_db_session(self) -> Generator[sqlite3.Connection, None, None]:
        """
        Context manager for database sessions with automatic cleanup.
        
        Yields:
            sqlite3.Connection: Database connection
            
        Example:
            with db_manager.get_db_session() as db:
                cursor = db.execute("SELECT * FROM users")
                results = cursor.fetchall()
        """
        conn = None
        try:
            conn = self.get_connection()
            yield conn
        except sqlite3.Error as e:
            if conn:
                conn.rollback()
            logger.error(f"Database session error: {e}")
            raise DatabaseError(f"Database operation failed: {e}")
        finally:
            if conn:
                conn.close()
    
    def initialize_schema(self) -> None:
        """
        Initialize database schema with all required tables.
        
        Creates tables for users and particles with proper constraints
        and foreign key relationships.
        
        Raises:
            DatabaseError: If schema initialization fails
        """
        try:
            with self.get_db_session() as db:
                # Enable foreign key support
                db.execute("PRAGMA foreign_keys = ON")
                
                # Users table
                db.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    username TEXT PRIMARY KEY,
                    password TEXT NOT NULL,
                    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1
                )
                """)
                
                # Particles table
                db.execute("""
                CREATE TABLE IF NOT EXISTS particles (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    content TEXT NOT NULL,
                    tags TEXT DEFAULT '',
                    section TEXT NOT NULL CHECK (section IN ('Projects', 'Areas', 'Resources', 'Archives')),
                    user TEXT NOT NULL,
                    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    FOREIGN KEY(user) REFERENCES users(username) ON DELETE CASCADE
                )
                """)
                
                # Create indexes for better performance
                db.execute("CREATE INDEX IF NOT EXISTS idx_particles_user ON particles(user)")
                db.execute("CREATE INDEX IF NOT EXISTS idx_particles_section ON particles(section)")
                db.execute("CREATE INDEX IF NOT EXISTS idx_particles_created ON particles(created)")
                
                # Create full-text search index for content
                db.execute("""
                CREATE VIRTUAL TABLE IF NOT EXISTS particles_fts USING fts5(
                    title, content, content='particles', content_rowid='id'
                )
                """)
                
                # Trigger to keep FTS table synchronized
                db.execute("""
                CREATE TRIGGER IF NOT EXISTS particles_fts_insert AFTER INSERT ON particles
                BEGIN
                    INSERT INTO particles_fts(rowid, title, content) VALUES (new.id, new.title, new.content);
                END
                """)
                
                db.execute("""
                CREATE TRIGGER IF NOT EXISTS particles_fts_delete AFTER DELETE ON particles
                BEGIN
                    INSERT INTO particles_fts(particles_fts, rowid, title, content) VALUES('delete', old.id, old.title, old.content);
                END
                """)
                
                db.execute("""
                CREATE TRIGGER IF NOT EXISTS particles_fts_update AFTER UPDATE ON particles
                BEGIN
                    INSERT INTO particles_fts(particles_fts, rowid, title, content) VALUES('delete', old.id, old.title, old.content);
                    INSERT INTO particles_fts(rowid, title, content) VALUES (new.id, new.title, new.content);
                END
                """)
                
                db.commit()
                logger.info("Database schema initialized successfully")
                
        except sqlite3.Error as e:
            logger.error(f"Schema initialization failed: {e}")
            raise DatabaseError(f"Failed to initialize database schema: {e}")
    
    def health_check(self) -> bool:
        """
        Check database health and connectivity.
        
        Returns:
            bool: True if database is healthy, False otherwise
        """
        try:
            with self.get_db_session() as db:
                db.execute("SELECT 1")
                return True
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False
    
    def get_table_info(self, table_name: str) -> list:
        """
        Get table schema information.
        
        Args:
            table_name: Name of the table
            
        Returns:
            list: Table schema information
        """
        try:
            with self.get_db_session() as db:
                cursor = db.execute(f"PRAGMA table_info({table_name})")
                return cursor.fetchall()
        except sqlite3.Error as e:
            logger.error(f"Failed to get table info for {table_name}: {e}")
            return []


# Global database manager instance
db_manager = DatabaseManager()


def get_db() -> sqlite3.Connection:
    """
    FastAPI dependency for database connections.
    
    Returns:
        sqlite3.Connection: Database connection
        
    Note:
        This function is used as a FastAPI dependency and should
        be used with Depends() in route handlers.
    """
    return db_manager.get_connection()


def init_database() -> None:
    """
    Initialize database schema on application startup.
    
    This function should be called during application startup
    to ensure all required tables and indexes exist.
    """
    db_manager.initialize_schema()